-- noinspection SqlDialectInspectionForFile

-- noinspection SqlNoDataSourceInspectionForFile

ALTER SESSION SET CURRENT_SCHEMA = V705417;

ALTER USER V705417 ACCOUNT UNLOCK;

DROP TABLE "BIN$1WYmf+KIQKClSCKi39nYJQ==$0";

SELECT * FROM EMPLOYEE;

SELECT * FROM SALARY;

SELECT * FROM DEPARTMENT;

-- EQUI JOIN
SELECT E.EMP_NAME, E.ADDRESS, E.DOB,
       D.DEPT_NAME, D.DEPT_LOC
FROM   EMPLOYEE E, DEPARTMENT D
WHERE  E.DEPT_ID = D.DEPT_ID;

SELECT E.EMP_NAME, E.ADDRESS, E.DOB,
       D.DEPT_NAME,D.DEPT_LOC
FROM   EMPLOYEE E  INNER JOIN  DEPARTMENT D
ON     E.DEPT_ID = D.DEPT_ID;

-- NON EQUI JOIN
SELECT E.EMP_ID, E.EMP_NAME, E.SALARY,
       S.LEVEL_NO
FROM   EMPLOYEE E, SALARY S
WHERE E.SALARY BETWEEN S.MIN_SAL AND S.MAX_SAL;

-- LEFT OUTER JOIN
SELECT E.EMP_NAME, E.ADDRESS, E.DOB,
       D.DEPT_NAME, D.DEPT_LOC
FROM   EMPLOYEE E, DEPARTMENT D
WHERE  E.DEPT_ID = D.DEPT_ID(+);

SELECT E.EMP_NAME, E.SALARY, D.DEPT_NAME, D.DEPT_LOC
FROM   EMPLOYEE E  LEFT OUTER JOIN  DEPARTMENT D  ON
E.DEPT_ID = D.DEPT_ID;

-- RIGHT OUTER JOIN
SELECT E.EMP_NAME, E.ADDRESS, E.DOB,
       D.DEPT_NAME, D.DEPT_LOC
FROM   EMPLOYEE E, DEPARTMENT D
WHERE  E.DEPT_ID(+) = D.DEPT_ID;

SELECT E.EMP_NAME,E.SALARY,
       D.DEPT_NAME,D.DEPT_ID,D.DEPT_LOC
FROM EMPLOYEE E RIGHT OUTER JOIN DEPARTMENT D
ON E.DEPT_ID = D.DEPT_ID;

-- FULL OUTER JOIN
SELECT E.*,D.*
FROM   EMPLOYEE E FULL OUTER JOIN DEPARTMENT D
ON     E.DEPT_ID = D.DEPT_ID;

SELECT E.*, D.* FROM EMPLOYEE E, DEPARTMENT D WHERE E.DEPT_ID = D.DEPT_ID;

--CROSS JOIN

SELECT E1.EMP_NAME AS EMP1
     , E2.EMP_NAME AS EMP2
     , ABS(E1.SALARY - E2.SALARY) AS SALARY_DIFF
FROM EMPLOYEE E1 CROSS JOIN EMPLOYEE E2
WHERE E1.SALARY != E2.SALARY
AND ROWNUM <=1 ORDER BY 3,1,2;

SELECT GENDER, LISTAGG(EMP_NAME, ',') WITHIN GROUP (ORDER BY EMP_NAME) "Names"
FROM   EMPLOYEE
GROUP BY GENDER;

SELECT GENDER, COUNT(GENDER) FROM EMPLOYEE GROUP BY GENDER;

SELECT DEPT_ID, COUNT(DEPT_ID) FROM EMPLOYEE GROUP BY DEPT_ID;

SELECT D.DEPT_NAME, D.DEPT_ID, COUNT(D.DEPT_NAME)
FROM EMPLOYEE E, DEPARTMENT D
WHERE E.DEPT_ID = D.DEPT_ID
GROUP BY(D.DEPT_NAME, D.DEPT_ID)
HAVING D.DEPT_ID IS NOT NULL;

-- Below will also work
SELECT D.DEPT_NAME, D.DEPT_ID, COUNT(D.DEPT_ID)
FROM EMPLOYEE E, DEPARTMENT D
WHERE E.DEPT_ID = D.DEPT_ID
GROUP BY(D.DEPT_NAME, D.DEPT_ID)
HAVING D.DEPT_ID IS NOT NULL;

SELECT E1.EMP_NAME"Manager", LISTAGG(E2.EMP_NAME, ' | ') WITHIN GROUP (ORDER BY E2.EMP_NAME)"Subordinates"
FROM EMPLOYEE E1, EMPLOYEE E2
WHERE E1.EMP_ID = E2.MGR_ID
GROUP BY E1.EMP_NAME;

SELECT E1.EMP_NAME, COUNT(E2.MGR_ID) FROM EMPLOYEE E1, EMPLOYEE E2 WHERE E1.EMP_ID = E2.MGR_ID GROUP BY E1.EMP_NAME;
---------------------------------------
EMP_NAME	COUNT(E2.MGR_ID)
---------------------------------------
Sekhar	        6
Naseer	        1
Govind	        4
---------------------------------------
--Find all Employee records containing the word "Joe", regardless of whether it was stored as JOE, Joe, or joe.
SELECT * FROM EMPLOYEE WHERE UPPER(EMP_NAME) LIKE '%JOE%';

--You have a composite index of three columns, and you only provide the value of two columns in
--WHERE clause of a select query? Will Index be used for this operation? For example if Index is
--on EmpId, EmpFirstName, and EmpSecondName and you write query like
--SELECT * FROM Employee WHERE EmpId=2 and EmpFirstName='Radhe'
--If the given two columns are secondary index column then the index will not invoke,
--but if the given 2 columns contain the primary index(first column while creating index)
--then the index will invoke. In this case, Index will be used because EmpId and EmpFirstName are primary columns.
-- Query to check whether date passed to Query is the date of given format or not.
--SELECT  ISDATE('1/08/13') AS "MM/DD/YY" FROM DUAL;

-- DISPLAY THE CURRENT USER
SHOW USER;

SET SQLPROMPT 'XE';
-- TO SWITCH TO DOS PROMPT 'HOST';
HOST;

-- DISPLAY THE RECORDS BETWEEN 2 RANGES
SELECT * FROM EMPLOYEE WHERE ROWID IN(SELECT ROWID FROM EMPLOYEE WHERE ROWNUM <= &UPTO MINUS SELECT ROWID FROM EMPLOYEE WHERE ROWNUM < &FRM);

--DISPLAY NTH HIGHEST SALARY
SELECT * FROM EMPLOYEE E1 WHERE &N = (SELECT COUNT(DISTINCT(E2.SALARY)) FROM EMPLOYEE E2 WHERE E1.SALARY <= E2.SALARY);

--DISPLAY NTH LOWEST SALARY
SELECT * FROM EMPLOYEE E1 WHERE &N = (SELECT COUNT(DISTINCT(E2.SALARY)) FROM EMPLOYEE E2 WHERE E1.SALARY >= E2.SALARY);

--DISPLAY ODD NUMBER OF RECORDS
SELECT * FROM EMPLOYEE WHERE(ROWID,1) IN(SELECT ROWID,MOD(ROWNUM,2) FROM EMPLOYEE);

--DISPLAY EVEN NUMBER OF RECORDS
SELECT * FROM EMPLOYEE WHERE(ROWID,0) IN(SELECT ROWID,MOD(ROWNUM,2) FROM EMPLOYEE);

-- DISPLAY THE NAMES OF ALL THE EMPLOYEE WHO ARE REPORTING TO THEIR RESPECTIVE MANAGERS
SELECT LPAD(E1.EMP_NAME,15,'*') ||' -> ' || RPAD(E2.EMP_NAME,10,'#')
FROM
EMPLOYEE E1 , EMPLOYEE E2
WHERE
E1.MGR_ID = E2.EMP_ID;

< ANY -> LESS THAN THE MAX VALUE
> ANY -> MORE THAN THE MIN VALUE
< ALL -> LESS THAN THE MIN VALUE
> ALL -> MORE THAN THE MAX VALUE

SELECT EMP_NAME, SALARY FROM EMPLOYEE WHERE SALARY < ANY(90000,50000);

SELECT EMP_NAME, SALARY FROM EMPLOYEE WHERE SALARY < ALL(90000,60000);

-- DISPLAY THE EMPLOYEE DETAILS GETTING MAXIMUM SALARY WITHOUT USING MAX FUNCTION
SELECT * FROM EMPLOYEE WHERE SALARY NOT IN(SELECT SALARY FROM EMPLOYEE WHERE SALARY < ANY(SELECT SALARY FROM EMPLOYEE));

-- OR BELOW QUERY ALSO WORKS
SELECT * FROM EMPLOYEE WHERE SALARY > ALL(SELECT SALARY FROM  EMPLOYEE WHERE SALARY < ANY(SELECT SALARY  FROM EMPLOYEE));

-- DISPLAY THE EMPLOYEE DETAILS GETTING MAXIMUM SALARY USING MAX FUNCTION
SELECT * FROM EMPLOYEE WHERE SALARY IN(SELECT MAX(SALARY) FROM EMPLOYEE);

-- DISPLAY THE EMPLOYEE DETAILS GETTING MINIMUM SALARY WITHOUT USING MIN FUNCTION
SELECT * FROM EMPLOYEE WHERE SALARY NOT IN(SELECT SALARY FROM EMPLOYEE WHERE SALARY > ANY (SELECT SALARY FROM EMPLOYEE));

--OR BELOW QUERY ALSO WORKS
SELECT * FROM EMPLOYEE WHERE SALARY < ALL(SELECT SALARY FROM EMPLOYEE WHERE SALARY > ANY (SELECT SALARY FROM EMPLOYEE));

--DISPLAY SECOND HIGHEST SALARY
SELECT MAX(SALARY) FROM EMPLOYEE WHERE SALARY NOT IN(SELECT MAX(SALARY) FROM EMPLOYEE);

SELECT MAX(SALARY) FROM EMPLOYEE WHERE SALARY IN(SELECT SALARY FROM EMPLOYEE WHERE SALARY < ANY (SELECT SALARY FROM  EMPLOYEE));

--DISPLAY THE EMPLOYEE DETAILS GETTING MINIMUM SALARY USING MIN FUNCTION
SELECT * FROM EMPLOYEE WHERE SALARY IN(SELECT MIN(SALARY) FROM  EMPLOYEE);

CREATE TABLE EMP (ID INTEGER , NAME VARCHAR2(10));

INSERT INTO EMP VALUES(1 ,'john@example.com');

INSERT INTO EMP VALUES(2 ,'bob@example.com');

INSERT INTO EMP VALUES(3 ,'john@example.com');

SELECT * FROM EMP;

DELETE FROM EMP WHERE ROWID NOT IN(SELECT MAX(ROWID) FROM EMP GROUP BY NAME);

--DELETE ALL THE DUPLICATE RECORDS FROM THE EMPLOYEE TABLE
DELETE FROM EMPLOYEE WHERE ROWID NOT IN(SELECT MAX(ROWID) FROM EMPLOYEE  GROUP BY EMP_ID);

DELETE FROM EMPLOYEE A WHERE ROWID <(SELECT MIN(ROWID) FROM EMPLOYEE B WHERE A.ENAME = B.ENAME);

--DISPLAY ALL THE UNIQUE RECORDS FROM THE TABLE
SELECT DISTINCT * FROM EMPLOYEE;

--DISPLAY ALL THE UNIQUE RECORDS FROM THE TABLE WITHOUT USING DISTINCT
SELECT * FROM EMPLOYEE WHERE ROWID IN(SELECT MAX(ROWID) FROM EMPLOYEE GROUP BY EMP_ID);

-- DISPLAY ROWNUM AND ROWID ALONG WITH ALL THE COLUMNS OF THE TABLE

SELECT ROWNUM,ROWID,E.* FROM EMPLOYEE E;

-- DISPLAY ALL THE DUPLICATE RECORDS FROM THE DATABASE TABLE EMPLOYEE
SELECT * FROM EMPLOYEE WHERE ROWID NOT IN(SELECT MAX(ROWID) FROM EMPLOYEE GROUP BY EMP_ID);

--DISPLAY THE RECORDS WHOSE NAME CONTAINS '_'
SELECT * FROM EMPLOYEE WHERE EMP_NAME LIKE '%/_%' ESCAPE'/';

--DISPLAY EMPLOYEE WHOSE HAVE N+ YEARS EXPERIENCE
SELECT * FROM EMPLOYEE WHERE DOJ<=(SYSDATE-(365*&N));

SELECT * FROM EMPLOYEE WHERE((SYSDATE-DOJ)/365)>=&N;

SELECT * FROM EMPLOYEE WHERE MONTHS_BETWEEN(SYSDATE,DOJ)/12 >= &N;

SELECT * FROM EMPLOYEE WHERE &N <= (SYSDATE-DOJ)/365;

--DISPLAY EMPLOYEE WHOSE JOINED ORGANIZATION IN THE LAST 26 MONTHS
SELECT * FROM EMPLOYEE WHERE DOJ>=(SYSDATE-30*26);

SELECT * FROM EMPLOYEE WHERE MONTHS_BETWEEN(SYSDATE,DOJ) <=26;

SELECT * FROM EMPLOYEE WHERE(SYSDATE-DOJ)/30 <=16;

SELECT * FROM EMPLOYEE WHERE SYSDATE-DOJ <= 30*16;

SELECT  D.DEPT_NAME"Department",E.EMP_NAME"Employee", MAX(E.SALARY)"Salary" FROM  EMPLOYEE E, DEPARTMENT D
WHERE  E.DEPT_ID = D.DEPT_ID
GROUP BY  D.DEPT_NAME,E.EMP_NAME,E.SALARY
HAVING E.SALARY IN(SELECT MAX(E1.SALARY) FROM EMPLOYEE E1 GROUP BY E1.DEPT_ID);

--DISPLAY THE NUMBER OF EMPLOYEES WORKING IN A PARTICULAR DEPARTMENT eg 'INV'
SELECT  D.DEPT_NAME, COUNT(D.DEPT_NAME)"Count" FROM  EMPLOYEE E, DEPARTMENT D
WHERE  E.DEPT_ID = D.DEPT_ID
GROUP BY  D.DEPT_NAME
HAVING  D.DEPT_NAME = 'VET';

SELECT COUNT(*) FROM EMPLOYEE WHERE DEPT_ID =(SELECT DEPT_ID FROM DEPARTMENT WHERE DEPT_NAME = 'VET');

SELECT  DEPT_ID, COUNT(DEPT_ID)"Count" FROM  EMPLOYEE
GROUP BY  DEPT_ID
HAVING  DEPT_ID =  (SELECT DEPT_ID FROM DEPARTMENT WHERE DEPT_NAME = 'VET');

--DISPLAY THE EMPLOYEE DETAILS WHOSE NAME SECOND LETTER IS 'b'
SELECT * FROM EMPLOYEE WHERE EMP_NAME LIKE '_b%';

********DISPLAY THE NAME OF EMPLOYEE WHO ARE WORKING UNDER THE MANAGER 'Govind'********
SELECT * FROM EMPLOYEE WHERE MGR_ID =(SELECT EMP_ID FROM EMPLOYEE WHERE EMP_NAME = 'Govind');

SELECT E1.EMP_NAME
FROM EMPLOYEE E1, EMPLOYEE E2
WHERE
E1.MGR_ID = E2.EMP_ID
AND E2.EMP_NAME='Govind';

-- DISPLAY ALL EMPLOYEE WHO ARE NOT MANAGERS

SELECT * FROM EMPLOYEE WHERE EMP_ID NOT IN(SELECT DISTINCT(MGR_ID) FROM EMPLOYEE);

********DISPLAY THE NAME OF EMPLOYEE WHO ARE WORKING UNDER THE MANAGER &MGR ********
SELECT * FROM EMPLOYEE WHERE MGR_ID =(SELECT EMP_ID FROM EMPLOYEE WHERE EMP_NAME='&MGR');

SELECT E1.EMP_NAME FROM EMPLOYEE E1, EMPLOYEE E2 WHERE E1.MGR_ID = E2.EMP_ID AND E2.EMP_NAME='&MGR';

********DISPLAY THE NUMBER OF EMPLOYEE WHO ARE WORKING UNDER THE MANAGER &MGR ********
SELECT COUNT(*) FROM EMPLOYEE
WHERE
MGR_ID=(SELECT EMP_ID FROM EMPLOYEE WHERE EMP_NAME='&MGR');

--DISPLAY THE TOTAL SALARY OF ALL EMPLOYEES OR TOTAL COST UNDER THE MANAGER Govind
SELECT SUM(SALARY) FROM EMPLOYEE WHERE EMP_NAME ='Govind' OR MGR_ID IN (SELECT EMP_ID FROM EMPLOYEE WHERE EMP_NAME='Govind');

--DISPLAY THE TOTAL SALARY OF ALL EMPLOYEES OR TOTAL COST UNDER Each Manager
SELECT  SUM(SALARY), MGR_ID FROM EMPLOYEE GROUP BY  MGR_ID;

SELECT SUM(E1.SALARY), E2.EMP_NAME FROM EMPLOYEE E1, EMPLOYEE E2 WHERE E1.MGR_ID = E2.EMP_ID GROUP BY E2.EMP_NAME;

--DISPLAY THE TOTAL NUMBER OF EMPLOYEE WORKING UNDER RESPECTIVE MANAGER
SELECT MGR_ID, COUNT(MGR_ID) FROM  EMPLOYEE GROUP BY  MGR_ID;

SELECT  E2.EMP_NAME, COUNT(E2.EMP_NAME)
FROM  EMPLOYEE E1, EMPLOYEE E2
WHERE  E1.MGR_ID = E2.EMP_ID
GROUP BY  E2.EMP_NAME;

--DISPLAY THE TOTAL NUMBER OF EMPLOYEE WORKING UNDER MANAGER 'Atmadeep'
SELECT  MGR_ID, COUNT(MGR_ID) FROM  EMPLOYEE GROUP BY MGR_ID HAVING  MGR_ID = (SELECT MGR_ID FROM EMPLOYEE WHERE EMP_NAME = 'Naseer');

SELECT COUNT(*) FROM EMPLOYEE WHERE MGR_ID =(SELECT EMP_ID FROM EMPLOYEE WHERE EMP_NAME = 'Naseer');

--DISPLAY THE EMPLOYEE DETAILS WHO ARE ALSO MANAGERS
SELECT * FROM EMPLOYEE WHERE EMP_ID IN(SELECT DISTINCT(MGR_ID) FROM EMPLOYEE);

SELECT E1.* FROM EMPLOYEE E1, EMPLOYEE E2 WHERE E1.EMP_ID = E2.MGR_ID;

--DISPLAY ALL THE EMPLOYEE WHOSE SALARY ARE GREATER THAN THE AVERAGE SALARY
SELECT * FROM EMPLOYEE WHERE SALARY>(SELECT AVG(SALARY) FROM EMPLOYEE);

--SQL QUERY TO FIND YEAR FROM A DATE
SELECT SYSDATE FROM DUAL;

SELECT CURRENT_DATE FROM DUAL;

SELECT SUBSTR(TO_CHAR(SYSDATE,'DD-MON-YYYY'),8,4)"YEAR" FROM DUAL;

SELECT TO_CHAR(SYSDATE,'DD-MM-YYYY,HH-MI-SS:AM')"SYSDATE" FROM DUAL;

SELECT TO_CHAR(SYSDATE,'DD-MON-YYYY,HH-MI-SS:AM')"Current Date and Time" FROM DUAL;

SELECT TO_CHAR(CURRENT_DATE,'DD-MON-YYYY,HH-MI-SS:AM')"Current Date and Time" FROM DUAL;

SELECT SALARY, TO_CHAR(TO_DATE(SALARY,'J'),'JSP') FROM EMPLOYEE;

ALTER TABLE EMPLOYEE MODIFY MARKS NUMBER(5);

CREATE SEQUENCE EMP_ID_SEQ START WITH 1 INCREMENT BY 1;

DROP TABLE B;

CREATE TABLE B(EMP_ID NUMBER PRIMARY KEY, EMP_NAME VARCHAR2(20) UNIQUE, PHONE_NO NUMBER(10) NOT NULL);

DESC B;

SELECT CONSTRAINT_NAME, CONSTRAINT_TYPE FROM USER_CONSTRAINTS WHERE TABLE_NAME = 'B';

ALTER TABLE B DROP PRIMARY KEY CASCADE;

ALTER TABLE B DROP CONSTRAINT SYS_C0010941;

ALTER TABLE B DROP CONSTRAINT SYS_C0010943;

DROP TABLE B;

ALTER TABLE B DISABLE CONSTRAINT PRIMARY KEY CASCADE;

ALTER TABLE B DISABLE CONSTRAINT SYS_C009893;

-- CASCADE CLAUSE IS NOT USED WITH ENABLE
ALTER TABLE B ENABLE PRIMARY KEY;

ALTER TABLE B ENABLE CONSTRAINT SYS_C009893;

SELECT * FROM EMPLOYEE;

SELECT LPAD(EMP_NAME,15,'*')   ||'     '   ||DOJ   ||'     '   ||SALARY "Employee Details" FROM EMPLOYEE;

SELECT PHONE_NUM+SALARY FROM EMPLOYEE;

SELECT TO_CHAR((DOJ+SALARY),'DD-MON-YYYY')FROM EMPLOYEE;

SELECT MONTHS_BETWEEN(SYSDATE,'07-OCT-1986')"Age in Month's" FROM DUAL;

SELECT(SYSDATE-(to_date('07-OCT-1986','DD-MON-YYYY')))/30 "Age in Month's" FROM DUAL;

SELECT(TO_DATE('07-OCT-1986')-TO_DATE('26-APR-1986'))/30 FROM DUAL;

SELECT * FROM DUAL;

DESC DUAL;

SELECT ROUND((SYSDATE-TO_DATE('07-OCT-1986'))/365,0)"Age" FROM DUAL;

SELECT ROUND(MONTHS_BETWEEN(SYSDATE,'07-OCT-1986')/12)"Age in year" FROM DUAL;

SELECT POWER(2,15) FROM DUAL;

DROP TABLE C1;

CREATE TABLE C1 ( CID INTEGER PRIMARY KEY, NAME VARCHAR2(20), ID INTEGER);

INSERT INTO C1 VALUES(1, 'ABC' , 1);
INSERT INTO C1 VALUES(2, 'ABC' , 1);
INSERT INTO C1 VALUES(3, 'ABC' , 1);
INSERT INTO C1 VALUES(4, 'PQR' , 2);
INSERT INTO C1 VALUES(5, 'PQR' , 2);

-- The below query will delete all the duplicate record
DELETE FROM C1 WHERE ROWID NOT IN(SELECT MAX(ROWID) FROM C1 GROUP BY(NAME,ID));

SELECT NAME, ID FROM C1 FOR UPDATE OF NAME, ID NOWAIT;

INSERT INTO C1 VALUES('ABC' , 1);

COMMIT;

CREATE USER V705417 IDENTIFIED BY PASSWORD;

ALTER USER V705417 IDENTIFIED BY PASSWORD;
alter session set "_ORACLE_SCRIPT"=true;
GRANT SELECT,UPDATE,INSERT,CREATE,TRUNCATE, COMMIT, ROLLBACK, SAVEPOINT, ALTER, INDEXES, EXECUTE, REFERENCES TO V705417;

GRANT ALL PRIVILEGES TO V705417;
REVOKE ALL PRIVILEGES FROM V705417;

REVOKE SELECT,UPDATE,INSERT,CREATE,TRUNCATE, COMMIT, ROLLBACK, SAVEPOINT, ALTER, INDEXES, EXECUTE, REFERENCES FROM V705417;

PURGE TABLE "BIN$Q/QyjqnaTcSoSSq0d7+6uA==$0";

CREATE ROLE ROLE_NAME;

GRANT SELECT,UPDATE,INSERT,CREATE,TRUNCATE, COMMIT, ROLLBACK, SAVEPOINT, ALTER, INDEXES, EXECUTE, REFERENCES TO ROLE_NAME;

GRANT ROLE_NAME TO USER_NAME;

REVOKE ROLE_NAME FROM USER_NAME;

REVOKE SELECT,UPDATE,INSERT,CREATE,TRUNCATE, COMMIT, ROLLBACK, SAVEPOINT, ALTER, INDEXES, EXECUTE, REFERENCES FROM USER_NAME;

SELECT INITCAP('ABHINAW KUMar bHAGAT') FROM DUAL;

SELECT ROUND(745.47,-1) FROM DUAL; -- 750

SELECT ROUND(744.47,-1) FROM DUAL; -- 740

SELECT ROUND(SYSDATE) FROM DUAL;

SELECT ROUND(SYSDATE+1,'MONTH') FROM DUAL;

SELECT ROUND(SYSDATE,'YEAR') FROM DUAL;

SELECT TRUNC(SYSDATE) FROM DUAL;

SELECT TRUNC(SYSDATE,'MONTH') FROM DUAL;

SELECT TRUNC(SYSDATE,'YEAR') FROM DUAL;

SELECT TO_CHAR(SALARY,'$099,99,999') FROM EMPLOYEE;

SELECT INSTR('ABCDEFGEJIEESS','E') FROM DUAL;

SELECT NEXT_DAY(SYSDATE,'SUNDAY') FROM DUAL;

--INLINE VIEW
SELECT ROWNUM, EMP_ID, EMP_NAME FROM(SELECT EMP_ID, EMP_NAME FROM EMPLOYEE ORDER BY SALARY DESC) WHERE ROWNUM <= 5;

-- STORE AN IMAGE IN DATABASE
CREATE TABLE IMAGE_T  (ID INTEGER, IMAGE BLOB);

INSERT INTO IMAGE_T VALUES(1 , utl_raw.cast_to_raw('D:\Java Study Materials\Image.jpg'));

SELECT * FROM IMAGE_T;

DELETE FROM IMAGE_T WHERE ROWID NOT IN(SELECT MAX(ROWID) FROM IMAGE_T GROUP BY ID);

SELECT EMP_NAME || EMP_ID AS "Name-ID", SALARY FROM EMPLOYEE;

CREATE OR REPLACE VIEW EMP_DEPT_V AS
SELECT  D.DEPT_NAME NAME, MIN(SALARY) LOWEST, AVG(SALARY) AVERAGE, MAX(SALARY) HIGHEST
FROM  EMPLOYEE   E, DEPARTMENT D
WHERE  E.DEPT_ID = D.DEPT_ID
GROUP BY  D.DEPT_NAME;

SELECT * FROM EMP_DEPT_V;

-- TO GET THE CURRENT DATE
SELECT CURRENT_DATE FROM DUAL;

CREATE TABLE DATE_V(TODAY_DATE DATE);

INSERT INTO DATE_V VALUES(CURRENT_DATE);

SELECT TO_CHAR(TODAY_DATE,'DD-MON-YYYY,HH:MI:SS AM') FROM DATE_V;

SELECT TO_CHAR(CURRENT_DATE,'DD-MON-YYYY,HH:MI:SS AM') FROM DUAL;

ALTER TABLE DEPARTMENT ADD CONSTRAINT FK FOREIGN KEY(DEPT_ID) REFERENCES EMPLOYEE ON DELETE CASCADE;
